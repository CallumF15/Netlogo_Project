;; navmesh structure: [ [<patch> ...] ...]
;; navmesh-matrix structure: [ [<adjacent-node> ...] ...]

globals [
  navmesh
  navmesh-matrix
]

to setup-navmesh
  ;; stub to populate world with obstacles
  let obstacles n-of obstacle-count-stub patches
  ask obstacles [
    set pcolor black
  ]

  set navmesh []
  set navmesh-matrix []

  ;; generate navmes and adjacency matrix
  let x 0
  repeat max-pxcor + 1 [
    let vertical-slab (list sort patches with [ pxcor = x ])
    let y max-pycor
    let segment-index 0

    ;; scan vertical slab
    foreach first vertical-slab [
      ask ? [
        if pcolor = black [
          ;; make new segment with patches below obstacle
          let new-segment filter [ [ pycor ] of ? < y ] last vertical-slab
          if not empty? new-segment [
            set vertical-slab lput new-segment vertical-slab
          ]

          ;; remove obstacle and patches below it from segment
          set vertical-slab replace-item segment-index vertical-slab filter [ [ pycor ] of ? > y ] item segment-index vertical-slab
          if empty? item segment-index vertical-slab [
            set vertical-slab remove-item segment-index vertical-slab
          ]

          set segment-index length vertical-slab - 1
        ]
      ]

      set y y - 1
    ]

    ifelse x > 0 [
      foreach vertical-slab [
        let segment ?
        
        let top-edge [ pycor ] of first segment
        let bottom-edge [ pycor ] of last segment
        let left-edge [ pxcor ] of first segment

        let unioned? false
        let neighboring-nodes filter [ [ pxcor ] of last ? + 1 = left-edge ] navmesh

        ;; union segments
        let union-node filter [ [ pycor ] of first ? = top-edge and [ pycor ] of last ? = bottom-edge ] neighboring-nodes
        if not empty? union-node [
          set union-node first union-node
          
          ;; add segment to union-node
          set navmesh replace-item (position union-node navmesh) navmesh sort sentence union-node segment

          ;; remove segment from vertical-slab
          set vertical-slab remove segment vertical-slab

          set unioned? true
        ]

        if not unioned? [
          set navmesh-matrix lput [] navmesh-matrix
          set segment-index length navmesh-matrix - 1

          ;; add entiries to adjacency matrix
          let adjacent-nodes filter [ [ pycor ] of first ? >= bottom-edge and [ pycor ] of last ? <= top-edge ] neighboring-nodes
          foreach adjacent-nodes [
            let node-index position ? navmesh

            set navmesh-matrix replace-item node-index navmesh-matrix lput segment-index item node-index navmesh-matrix
            set navmesh-matrix replace-item segment-index navmesh-matrix lput node-index item segment-index navmesh-matrix
          ]
        ]
      ]
    ] [
      foreach vertical-slab [
        set navmesh-matrix lput [] navmesh-matrix
      ]
    ]

    ;; add segments to navmesh
    foreach vertical-slab [
      set navmesh lput ? navmesh
    ]

    set x x + 1
  ]

  update-navmesh-display
end



to-report get-centre [ #node ]
  ifelse #node < 0 or #node >= length navmesh [
    report []
  ] [
    let x 0
    let y 0
    
    foreach item #node navmesh [
      set x x + [ pxcor ] of ?
      set y y + [ pycor ] of ?
    ]
    
    report map [ ? / length item #node navmesh ] (list x y)
  ]
end



to-report get-edge-midpoint [ #node1 #node2 ]
  ifelse #node1 < 0 or #node1 >= length navmesh or #node2 < 0 or #node2 >= length navmesh [
    report [ 0 0 ]
  ] [
    let node1 item #node1 navmesh
    let node2 item #node2 navmesh
    
    let top-edge-1 filter [ [ pycor ] of ? = [ pycor ] of first node1 ] node1
    let bottom-edge-1 filter [ [ pycor ] of ? = [ pycor ] of last node1 ] node1
    let left-edge-1 filter [ [ pxcor ] of ? = [ pxcor ] of first node1 ] node1
    let right-edge-1 filter [ [ pxcor ] of ? = [ pxcor ] of last node1 ] node1
    
    let top-edge-2 filter [ [ pycor ] of ? = [ pycor ] of first node2 ] node2
    let bottom-edge-2 filter [ [ pycor ] of ? = [ pycor ] of last node2 ] node2
    let left-edge-2 filter [ [ pxcor ] of ? = [ pxcor ] of first node2 ] node2
    let right-edge-2 filter [ [ pxcor ] of ? = [ pxcor ] of last node2 ] node2
    
    let shared-edge []
    let orientation "horizontal"
    
    let x 0
    let y 0
    
    ifelse [ pycor ] of first top-edge-1 < [ pycor ] of first bottom-edge-2 [
      ;; node1 is bellow node2
      set y ([ pycor ] of first top-edge-1 + 0.5 + [ pycor ] of first bottom-edge-2 - 0.5) / 2
      set shared-edge (list top-edge-1 bottom-edge-2)
    ] [
      ifelse [ pycor ] of first top-edge-2 < [ pycor ] of first bottom-edge-1 [
        ;; node2 is bellow node1
        set y ([ pycor ] of first top-edge-2 + 0.5 + [ pycor ] of first bottom-edge-1 - 0.5) / 2
        set shared-edge (list top-edge-2 bottom-edge-1)
      ] [
        set orientation "edge"
      
        ifelse [ pxcor ] of first left-edge-1 > [ pxcor ] of first right-edge-2 [
          ;; node1 is to the right of node2
          set x ([ pxcor ] of first left-edge-1 + 0.5 + [ pxcor ] of first bottom-edge-2 - 0.5) / 2
          set shared-edge (list left-edge-1 right-edge-2)
        ] [
          ;; node2 is to the right of node1
          set x ([ pxcor ] of first left-edge-2 + 0.5 + [ pxcor ] of first bottom-edge-1 - 0.5) / 2
          set shared-edge (list left-edge-2 right-edge-1)
        ]
      ]
    ]
    
    ifelse orientation = "horizontal" [
      let edge-set []
      foreach first shared-edge [
        let x1 [ pxcor ] of ?
        
        foreach last shared-edge [
          let x2 [ pxcor ] of ?
          
          if x1 = x2 [
            set edge-set lput x1 edge-set
          ]
        ]
      ]
      
      set x (min edge-set + max edge-set) / 2
    ] [
      let edge-set []
      foreach first shared-edge [
        let y1 [ pycor ] of ?
        
        foreach last shared-edge [
          let y2 [ pycor ] of ?
          
          if y1 = y2 [
            set edge-set lput y1 edge-set
          ]
        ]
      ]
      
      set y (min edge-set + max edge-set) / 2
    ]
    
    report (list x y)
  ]
end



to-report containing-node [ #patch ]
  ifelse not is-patch? #patch [
    report -1
  ] [
    let index 0
    
    foreach navmesh [
      if member? #patch ? [
        report index
      ]
      
      set index index + 1
    ]
    
    report -1
  ]
end



to-report adjacency-list [ #node ]
  ifelse #node < 0 or #node >= length navmesh-matrix [
    report []
  ] [
    report item #node navmesh-matrix
  ]
end



to update-navmesh-display
  toggle-color-navmesh
  toggle-label-navmesh
end



to toggle-color-navmesh
  let node-colors ifelse-value color-navmesh? [
    filter [ ? != black ] base-colors
  ] [
    [ green ]
  ]
  let index 0

  foreach navmesh [
    foreach ? [
      ask ? [
        set pcolor item index node-colors
      ]
    ]

    set index ifelse-value (index + 1 = length node-colors) [ 0 ] [ index + 1 ]
  ]
end



to toggle-label-navmesh
  ifelse label-navmesh? [
    let node-label 0
    
    foreach navmesh [
      foreach ? [
        ask ? [
          set plabel node-label
        ]
      ]
      
      set node-label node-label + 1
    ]
  ] [
    foreach navmesh [
      foreach ? [
        ask ? [
          set plabel ""
        ]
      ]
    ]
  ]
end



to output-navmesh
  let index 0
  foreach navmesh [
    output-show (word index ": " ?)
    set index index + 1
  ]
end



to output-navmesh-matrix
  let index 0
  foreach navmesh-matrix [
    output-show (word index ": " ?)
    set index index + 1
  ]
end
